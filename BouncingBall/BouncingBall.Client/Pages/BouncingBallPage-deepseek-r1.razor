@page "/deepseek-r1"
@using System.Timers
@inject IJSRuntime JSRuntime
@rendermode InteractiveWebAssembly
<canvas id="canvas" width="800" height="600"></canvas>

@code {

    private Timer timer;
    private double rotationAngle;
    private double ballX, ballY;
    private double ballVx, ballVy;
    private const double BallRadius = 10;
    private const double HexagonRadius = 200;
    private const double Gravity = 0.5;
    private const double Friction = 0.99;
    private const double AngularVelocity = 0.02;
    private const double BounceCoefficient = 0.8;
    private readonly Point center = new(400, 300);

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("initCanvas");
            ResetBall();
        }
        timer = new Timer(16);
        timer.Elapsed += async (sender, e) => await Update();
        timer.Start();
    }

    protected override void OnInitialized()
    {
        // timer = new Timer(16);
        // timer.Elapsed += async (sender, e) => await Update();
        // timer.Start();
    }

    private void ResetBall()
    {
        ballX = center.X;
        ballY = center.Y - HexagonRadius * 0.5;
        ballVx = 5;
        ballVy = 0;
    }

    private async Task Update()
    {
        rotationAngle += AngularVelocity;

        // Apply physics
        ballVy += Gravity;
        ballVx *= Friction;
        ballVy *= Friction;
        ballX += ballVx;
        ballY += ballVy;

        CheckCollisions();
        await Draw();
    }

    private void CheckCollisions()
    {
        var vertices = GetHexagonVertices();

        for (int i = 0; i < 6; i++)
        {
            var a = vertices[i];
            var b = vertices[(i + 1) % 6];
            var closest = ClosestPointOnSegment(a, b, new(ballX, ballY));
            var dx = ballX - closest.X;
            var dy = ballY - closest.Y;
            var distance = Math.Sqrt(dx * dx + dy * dy);

            if (distance <= BallRadius)
            {
                var normal = CalculateNormal(a, b);
                var collisionPoint = closest;
                var wallVelocity = CalculateWallVelocity(collisionPoint);

                // Calculate relative velocity
                var relVx = ballVx - wallVelocity.X;
                var relVy = ballVy - wallVelocity.Y;

                // Reflect velocity
                var dot = relVx * normal.X + relVy * normal.Y;
                ballVx = relVx - 2 * dot * normal.X + wallVelocity.X;
                ballVy = relVy - 2 * dot * normal.Y + wallVelocity.Y;

                // Apply bounce coefficient
                ballVx *= BounceCoefficient;
                ballVy *= BounceCoefficient;

                // Reposition ball
                var overlap = BallRadius - distance;
                ballX += normal.X * overlap;
                ballY += normal.Y * overlap;
            }
        }
    }

    private Point ClosestPointOnSegment(Point a, Point b, Point p)
    {
        var ax = p.X - a.X;
        var ay = p.Y - a.Y;
        var bx = b.X - a.X;
        var by = b.Y - a.Y;

        var t = (ax * bx + ay * by) / (bx * bx + by * by);
        t = Math.Max(0, Math.Min(1, t));

        return new(a.X + bx * t, a.Y + by * t);
    }

    private Point CalculateNormal(Point a, Point b)
    {
        var midpoint = new Point((a.X + b.X) / 2, (a.Y + b.Y) / 2);
        var normal = new Point(center.X - midpoint.X, center.Y - midpoint.Y);
        var length = Math.Sqrt(normal.X * normal.X + normal.Y * normal.Y);
        return new(normal.X / length, normal.Y / length);
    }

    private Point CalculateWallVelocity(Point p)
    {
        var relX = p.X - center.X;
        var relY = p.Y - center.Y;
        return new(-AngularVelocity * relY, AngularVelocity * relX);
    }

    private List<Point> GetHexagonVertices()
    {
        var vertices = new List<Point>();
        for (int i = 0; i < 6; i++)
        {
            var angle = rotationAngle + i * Math.PI / 3;
            var x = center.X + HexagonRadius * Math.Cos(angle);
            var y = center.Y + HexagonRadius * Math.Sin(angle);
            vertices.Add(new(x, y));
        }
        return vertices;
    }

    private async Task Draw()
    {
        await JSRuntime.InvokeVoidAsync("clearCanvas");
        var vertices = GetHexagonVertices().Select(v => new { x = v.X, y = v.Y }).ToArray();
        await JSRuntime.InvokeVoidAsync("drawHexagon", vertices);
        await JSRuntime.InvokeVoidAsync("drawBall", ballX, ballY, BallRadius);
    }

    public record Point(double X, double Y);

}
